using this as a reference
 Map<Integer, Integer> followedGames = notifCheck();
            List<LiveGame> liveGames = this.notificationSearch();
            boolean shouldSleep = false;
            if(followedGames == null){
                shouldSleep = true;
            } else{
                //logic to send notifications
                //for game in followed game
//                int oldCount = databaseRepository.getEventCount() // followed game id

                for (LiveGame game : liveGames){
                    if(followedGames.get(game.getId()) != null){
                        int newCount = game.getEvents().size();
                        int oldCount = followedGames.get(game.getId());
                        if(newCount > oldCount){
                            for(int i=newCount; i >oldCount; i++){
                                sendNotif(game.getEventAtIndex(i), game.getId(), game.leagueId);
                            }
                        }

                    }
                    
                }

how can I check if a followedgame is in livegames

ChatGPT
To check if a followedGame is in the liveGames list, you can iterate through the liveGames list and compare the id of each LiveGame with the keys in the followedGames map. If there is a match, it means that the followedGame is present in the liveGames list. Here's how you can modify your code to achieve this:

java
Copy code
Map<Integer, Integer> followedGames = notifCheck();
List<LiveGame> liveGames = this.notificationSearch();
boolean shouldSleep = false;

if (followedGames == null) {
    shouldSleep = true;
} else {
    // Logic to send notifications for games in followedGames that are in liveGames
    for (LiveGame game : liveGames) {
        Integer followedGameCount = followedGames.get(game.getId());

        if (followedGameCount != null) {
            int newCount = game.getEvents().size();

            if (newCount > followedGameCount) {
                for (int i = newCount - 1; i >= followedGameCount; i--) {
                    sendNotif(game.getEventAtIndex(i), game.getId(), game.getLeagueId());
                }
            }
        }
    }
}
In this modified code:

I've used Integer followedGameCount = followedGames.get(game.getId()); to get the count of events for the corresponding game ID in followedGames.
If followedGameCount is not null, it means the game is in the followedGames map.
The code then compares newCount with followedGameCount to determine if there are new events for that game.
If there are new events, it sends notifications for each new event from followedGameCount to newCount - 1.
User
I dont want to count them, I want to call a method if they arent featured
ChatGPT
If you want to call a method for the followedGame instances that are not in liveGames, you can iterate through the followedGames map and check if the corresponding game ID exists in the liveGames list. If it doesn't, you can call your method. Here's how you can modify your code for this purpose:

java
Copy code
Map<Integer, Integer> followedGames = notifCheck();
List<LiveGame> liveGames = this.notificationSearch();
boolean shouldSleep = false;

if (followedGames == null) {
    shouldSleep = true;
} else {
    // Logic to send notifications for games in followedGames that are in liveGames
    for (Map.Entry<Integer, Integer> entry : followedGames.entrySet()) {
        Integer gameId = entry.getKey();

        // Check if the game with gameId is in liveGames
        boolean isGameInLiveGames = liveGames.stream().anyMatch(game -> game.getId() == gameId);

        if (!isGameInLiveGames) {
            // Call your method here for games that are in followedGames but not in liveGames
            yourMethod(gameId);
        }
    }
}
In this modified code:

I'm using followedGames.entrySet() to iterate through the entries (key-value pairs) of the followedGames map.
For each entry, I extract the gameId using entry.getKey().
I use the anyMatch method of the Stream API to check if there is any game in liveGames with the same gameId.
If there is no match, it means the gameId is not in liveGames, and you can call your method (yourMethod(gameId)) for that game.


















given the following java code give me a method to sort events by minute, take into consideration that minute is a string in formats such as 57, or 45+1. It should be sorted by the first number first, so consider splitting on the + sign if there is one


package com.example.mobileappdevcoursework;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;


public class LiveGame {

    String title;
    int id;
    String startTime;
    int venueID;
    String venue;
    String homeName;
    String awayName;
    int homePos;
    int awayPos;
    List<Event> events;
    String score;
    int leagueId;

    public LiveGame(String title, String date, int id, int venueID,
                            String homeName, String awayName, int homePos, int awayPos,
                            List<Event> events, String score, int leagueId) {
        this.title = title;
        this.startTime = date;
        this.id = id;
        this.venueID = venueID;
        this.venue = getVenue();
        this.homeName = homeName;
        this.awayName = awayName;
        this.homePos = homePos;
        this.awayPos = awayPos;
        if (events != null) {
            this.events = events;
        } else {
            this.events = new ArrayList<>();
        }
        this.score = score;
        this.leagueId = leagueId;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "LiveGame{" +
                "title='" + title + '\'' +
                ", id=" + id +
                ", startTime='" + startTime + '\'' +
                ", venueID=" + venueID +
                ", venue='" + venue + '\'' +
                ", homeName='" + homeName + '\'' +
                ", awayName='" + awayName + '\'' +
                ", homePos=" + homePos +
                ", awayPos=" + awayPos +
                ", events=" + events +
                ", score='" + score + '\'' +
                ", leagueId=" + leagueId +
                '}';
    }

    public String getTitle() {
        return title;
    }


    public String getStartTime() {
        return startTime;
    }

    public int getVenueID() {
        return venueID;
    }


    public String getHomeName() {
        return homeName;
    }

    public String getAwayName() {
        return awayName;
    }

    public int getHomePos() {
        return homePos;
    }

    public int getAwayPos() {
        return awayPos;
    }

    public List<Event> getEvents() {
        return events;
    }

    public String getScore() {
        return score;
    }

    public int eventCount() {
        return this.events.size();
    }
    public String getVenue() {
        final StringBuilder venue = new StringBuilder();

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    URL url = new URL("https://api.sportmonks.com/v3/football/venues/" + venueID + "?api_token=vHnHu2OZtUGbhPvHGl9NhDXH5iv7lSGOSPvOhJ6gYwD91Q9X3NoA2CjA1xzr");
                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();

                    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                    String inputLine;
                    StringBuilder content = new StringBuilder();

                    while ((inputLine = in.readLine()) != null) {
                        content.append(inputLine);
                    }
                    in.close();
                    connection.disconnect();

                    if (content != null) {
                        String jsonString = content.toString();
                        venue.append(jsonParser.getVenue(jsonString));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();

        try {
            // Wait for the thread to finish
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return venue.toString();
    }



    public String getHomeEventList() {
        StringBuilder stringBuilder = new StringBuilder();

        for (Event event : this.events) {
//            stringBuilder.append("Event ID: ").append(event.getId()).append("\n");
//            stringBuilder.append("Event Name: ").append(event.getName()).append("\n");
//            stringBuilder.append("Event Minute: ").append(event.getMinute()).append("\n");
            if(event.getTeam() == "home") {
                stringBuilder.append(event.getName()).append("\n");
                System.out.println("added home event");
            }else{
                stringBuilder.append("---------------\n\n");
            }


        }

        return stringBuilder.toString();
    }

    public String getAwayEventList() {
        StringBuilder stringBuilder = new StringBuilder();

        for (Event event : this.events) {
//            stringBuilder.append("Event ID: ").append(event.getId()).append("\n");
//            stringBuilder.append("Event Name: ").append(event.getName()).append("\n");
//            stringBuilder.append("Event Minute: ").append(event.getMinute()).append("\n");
            if(event.getTeam() == "away") {
                stringBuilder.append(event.getName()).append("\n");
                System.out.println("added away event");
            }else{
                stringBuilder.append("---------------\n\n");
            }



        }

        return stringBuilder.toString();
    }
    public String getMins(){
        StringBuilder stringBuilder = new StringBuilder();
        for (Event event: this.events){
            stringBuilder.append(event.getMinute()).append("\n");

        }
        return stringBuilder.toString();
    }

    public Event getEventAtIndex(int index) {
        if (index >= 0 && index < events.size()) {
            return events.get(index);
        } else {
            throw new IndexOutOfBoundsException("Invalid index: " + index);
        }
    }
ChatGPT
To sort the events by minute, considering the minute is a string in formats such as "57" or "45+1," you can create a method in the LiveGame class. Here's an example of how you can achieve this using the Collections.sort method with a custom comparator:

java
Copy code
import java.util.Comparator;

public class LiveGame {

    // ... (existing code)

    // Add this method to sort events by minute
    public void sortEventsByMinute() {
        Collections.sort(events, new Comparator<Event>() {
            @Override
            public int compare(Event event1, Event event2) {
                // Split on '+' if present to get the first part of the minute
                String minute1 = event1.getMinute().split("\\+")[0];
                String minute2 = event2.getMinute().split("\\+")[0];

                // Convert to integers for comparison
                int minuteValue1 = Integer.parseInt(minute1);
                int minuteValue2 = Integer.parseInt(minute2);

                // Compare the minutes
                return Integer.compare(minuteValue1, minuteValue2);
            }
        });
    }

    // ... (existing code)

}
You can then call this method before using or displaying the events to ensure that they are sorted by minute. For example:

java
Copy code
LiveGame liveGame = // create an instance of LiveGame
liveGame.sortEventsByMinute();
This will sort the events based on the numeric value of the minutes, even if there is a '+' sign indicating additional time.






explain why 
class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;

    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    @Override
    public void run() {
        scheduler.scheduleAtFixedRate(() -> {
            long startTime = System.currentTimeMillis();
            notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");
        }, 0, 10, TimeUnit.SECONDS);
    }

    private void notifCheck() {

        // Your code to be executed every 10 seconds
        long startTime = System.currentTimeMillis();
        new Thread(() -> {
            try{
            // Perform network-related operation in a background thread
                Thread.sleep(10000);
            List<LiveGame> liveGames = this.notificationSearch();
            if(liveGames == null){
                Thread.sleep(60000);
            } else {
                System.out.println(liveGames.toString());
                List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
                Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);
                for (FollowedGame followedGame : followedGames) {
                    // Check if the FollowedGame is not in liveGames
                    boolean isFollowedGameInLiveGames = false;

                    for (LiveGame liveGame : liveGames) {
                        if (liveGame.getId() == followedGame.getGameID()) {
                            isFollowedGameInLiveGames = true;
                            break;
                        }
                    }

                    // If the FollowedGame is not in liveGames, delete it
                    if (!isFollowedGameInLiveGames) {
                        databaseRepository.deleteFollowedGame(followedGame.getGameID());
                    }
                }
                for (LiveGame game : liveGames) {
                    if (followedGamesMap.get(game.getId()) != null) {
                        if (game.eventCount() > followedGamesMap.get(game.getId())) {
                            for (int i = followedGamesMap.get(game.getId()); i < game.eventCount(); i++) {
                                Event event = game.getEventAtIndex(i);
                                sendNotif(event);
                            }
                        }
                    }
                }

                System.out.println("Executing myFunction every 10 seconds");
            }
            } catch (InterruptedException e) {
                    e.printStackTrace();
                }


            // Continue processing the data in the background thread

        }).start();
        long endTime = System.currentTimeMillis();
        System.out.println("notifCheck execution time: " + (endTime - startTime) + " ms");

    }



    private static Map<Integer, Integer> convertListToMap(List<FollowedGame> followedGamesList) {
        Map<Integer, Integer> gameIdToEventCountMap = new HashMap<>();
        for (FollowedGame game : followedGamesList) {
            gameIdToEventCountMap.put(game.getGameID(), game.getEventCount());
        }
        return gameIdToEventCountMap;
    }

    public void sendNotif(Event event) {
        final String CHANNEL_ID = "App_Title_id";
        List<String> notif = new ArrayList<>();
        notif = parseForNotif(event);
        String textTitle = notif.get(0);
        String textContent = notif.get(1);
        Context context = this.context;

        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)
                .setContentTitle(textTitle)
                .setContentText(textContent)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT);

        int notificationId = createID(textTitle);
        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);

        //this if statement auto generated by android studio
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return;
        }
        notificationManager.notify(notificationId, builder.build());
    }

    public static int createID(String input) {
        int sum = 0;

        // Check for null or empty string
        if (input != null && !input.isEmpty()) {
            // Iterate through each character in the string
            for (char c : input.toCharArray()) {
                // Add the ASCII value of the character to the sum
                sum += (int) c;
            }
        }

        return sum;
    }
    public static List<String> parseForNotif(Event event){
        List<String> notif = new ArrayList<>();

        //(new Event(eventId, eventName, eventMinute, result, addition, teamName))
        if (event.getAddition().isEmpty()){
            notif.add(event.getMinute() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());

        }else{
            notif.add(event.getMinute() + " + " + event.getAddition() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());
        }
        if (event.getAddition().isEmpty()){
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + "' "  +  " the score is: " + event.getResult());


        }else{
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + " + " + event.getAddition() + "' "  +  " the score is: " + event.getResult());

        }



        return notif;
    }

    public List<LiveGame> notificationSearch() {
        List<LiveGame> liveGames = new ArrayList<>();
        int leagueID = databaseRepository.getLeague();

        try {
            //System.out.println(leagueID);
            URL url = new URL("https://api.sportmonks.com/v3/football/livescores/inplay?api_token=vHnHu2OZtUGbhPvHGl9NhDXH5iv7lSGOSPvOhJ6gYwD91Q9X3NoA2CjA1xzr&include=events;participants&filters=fixtureLeagues:" + leagueID);

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder content = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            in.close();
            connection.disconnect();

            if (content != null) {
                String jsonString = content.toString();
                //System.out.println("here " + jsonString);
                boolean shouldDelay = false;
                System.out.println(shouldDelay);
                System.out.println(jsonString);
                if (jsonString.contains("No result(s) found")) {
                    return null;
                }


                liveGames = jsonParser.parseLiveJson(jsonString);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return liveGames;
    }
}

returns
 {"message":"No result(s) found matching your request. Either the query did not return any results or you don't have access to it via your current subscription.","subscription":[{"meta":[],"plans":[{"plan":"Football Free Plan","sport":"Football","category":"Standard"},{"plan":"Cricket Free Plan","sport":"Cricket","category":"Standard"}],"add_ons":[],"widgets":[]}],"rate_limit":{"resets_in_seconds":2775,"remaining":2927,"requested_entity":"Fixture"},"timezone":"UTC"}


instead of null
ChatGPT
The issue seems to be related to the response you're getting from the API call in the notificationSearch method. The API response contains a message indicating that no results were found matching the request. This message is likely present in the jsonString:

json
Copy code
{
  "message": "No result(s) found matching your request. Either the query did not return any results or you don't have access to it via your current subscription.",
  "subscription": [...],
  "rate_limit": {...},
  "timezone": "UTC"
}
In your code, you have the following check:

java
Copy code
if (jsonString.contains("No result(s) found")) {
    return null;
}
This check is designed to return null if the response message contains "No result(s) found." However, the actual message in the response is:

json
Copy code
"No result(s) found matching your request. Either the query did not return any results or you don't have access to it via your current subscription."
To fix this issue, you should modify your check to account for the full message:

java
Copy code
if (jsonString.contains("\"message\":\"No result(s) found matching your request.")) {
    return null;
}
This modification ensures that you are checking for the exact message present in the API response. If the message matches, it means there are no results, and you can return null.

2023-11-29 16:29:22.588 11772-11845 System.out              com.example.mobileappdevcoursework   I  sleep for 1 min
2023-11-29 16:29:27.397 11772-11838 System.out              com.example.mobileappdevcoursework   I  notifCheck execution time: 0 ms
2023-11-29 16:29:27.397 11772-11838 System.out              com.example.mobileappdevcoursework   I  Execution time: 0 ms
2023-11-29 16:29:27.506 11772-11846 System.out              com.example.mobileappdevcoursework   I  sleep for 1 min
2023-11-29 16:29:32.480 11772-11796 System.out              com.example.mobileappdevcoursework   I  notifCheck execution time: 0 ms
2023-11-29 16:29:32.480 11772-11796 System.out              com.example.mobileappdevcoursework   I  Execution time: 0 ms
2023-11-29 16:29:32.822 11772-11847 System.out              com.example.mobileappdevcoursework   I  sleep for 1 min
2023-11-29 16:29:37.397 11772-11838 System.out              com.example.mobileappdevcoursework   I  notifCheck execution time: 1 ms
2023-11-29 16:29:37.397 11772-11838 System.out              com.example.mobileappdevcoursework   I  Execution time: 1 ms
2023-11-29 16:29:37.501 11772-11849 System.out              com.example.mobileappdevcoursework   I  sleep for 1 min

from 
package com.example.mobileappdevcoursework;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.navigation.NavController;
import androidx.navigation.fragment.NavHostFragment;

import com.example.mobileappdevcoursework.databinding.ActivityMainBinding;

import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity {
    ActivityMainBinding binding;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //setContentView(R.layout.activity_main);


        //code for the navigation bar comes from https://www.youtube.com/watch?v=jOFLmKMOcK0 , accessed 14/11/2023 at 10am the switch case at 7:54 was adapted to a series of if else statements to fix a constant expression required error
        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());


        NavHostFragment navHostFragment = (NavHostFragment) getSupportFragmentManager().findFragmentById(R.id.nav_host_fragment);

        //replaceFragment(new HomeFragment());
        NavController navController = navHostFragment.getNavController();


        new Thread(() -> {
            createNotificationChannel();
            LiveViewModel viewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(LiveViewModel.class);
            DatabaseRepository databaseRepository = DatabaseRepository.getRepository(this);
            Notifications notificationManager = new Notifications(this,  databaseRepository);
            notificationManager.run();
        }).start();


        binding.bottomNavigationView.setOnNavigationItemSelectedListener(item -> {
            if (item.getItemId() == R.id.main) {
                navController.navigate(R.id.HomeFragment);
                return true;
            } else if (item.getItemId() == R.id.profile) {
                navController.navigate(R.id.userProfile);
                return true;
            } else if (item.getItemId() == R.id.live) {
                navController.navigate(R.id.liveScores);
                return true;
            }
            return false;
        });


    }

    private void createNotificationChannel() {
        // Create the NotificationChannel, but only on API 26+ because
        // the NotificationChannel class is not in the Support Library.
        final String CHANNEL_ID = "App_Title_id";

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            CharSequence name = getString(R.string.channel_name);
            String description = getString(R.string.channel_description);
            int importance = NotificationManager.IMPORTANCE_DEFAULT;
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
            channel.setDescription(description);
            // Register the channel with the system; you can't change the importance
            // or other notification behaviors after this.
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(channel);
        }
    }

    private void replaceFragment(Fragment fragment) {
        Log.d("MainActivity", "Replacing fragment with " + fragment.getClass().getSimpleName());

        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        if (fragment != null) {
            fragmentTransaction.replace(R.id.frameLayout, fragment);
            fragmentTransaction.commit();
        } else {
            Log.e("MainActivity", "Fragment is null");
        }

    }
}

class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;

    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    @Override
    public void run() {
        scheduler.scheduleAtFixedRate(() -> {
            long startTime = System.currentTimeMillis();
            notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");
        }, 0, 10, TimeUnit.SECONDS);
    }

    private void notifCheck() {

        // Your code to be executed every 10 seconds
        long startTime = System.currentTimeMillis();
        new Thread(() -> {
            try{
            // Perform network-related operation in a background thread
                Thread.sleep(10000);
            List<LiveGame> liveGames = this.notificationSearch();
            if(liveGames == null){
                System.out.println("sleep for 1 min");
                Thread.sleep(60000);
            } else {
                System.out.println(liveGames.toString());
                List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
                Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);
                for (FollowedGame followedGame : followedGames) {
                    // Check if the FollowedGame is not in liveGames
                    boolean isFollowedGameInLiveGames = false;

                    for (LiveGame liveGame : liveGames) {
                        if (liveGame.getId() == followedGame.getGameID()) {
                            isFollowedGameInLiveGames = true;
                            break;
                        }
                    }

                    // If the FollowedGame is not in liveGames, delete it
                    if (!isFollowedGameInLiveGames) {
                        databaseRepository.deleteFollowedGame(followedGame.getGameID());
                    }
                }
                for (LiveGame game : liveGames) {
                    if (followedGamesMap.get(game.getId()) != null) {
                        if (game.eventCount() > followedGamesMap.get(game.getId())) {
                            for (int i = followedGamesMap.get(game.getId()); i < game.eventCount(); i++) {
                                Event event = game.getEventAtIndex(i);
                                sendNotif(event);
                            }
                        }
                    }
                }

                System.out.println("Executing myFunction every 10 seconds");
            }
            } catch (InterruptedException e) {
                    e.printStackTrace();
                }


            // Continue processing the data in the background thread

        }).start();
        long endTime = System.currentTimeMillis();
        System.out.println("notifCheck execution time: " + (endTime - startTime) + " ms");

    }



    private static Map<Integer, Integer> convertListToMap(List<FollowedGame> followedGamesList) {
        Map<Integer, Integer> gameIdToEventCountMap = new HashMap<>();
        for (FollowedGame game : followedGamesList) {
            gameIdToEventCountMap.put(game.getGameID(), game.getEventCount());
        }
        return gameIdToEventCountMap;
    }

    public void sendNotif(Event event) {
        final String CHANNEL_ID = "App_Title_id";
        List<String> notif = new ArrayList<>();
        notif = parseForNotif(event);
        String textTitle = notif.get(0);
        String textContent = notif.get(1);
        Context context = this.context;

        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)
                .setContentTitle(textTitle)
                .setContentText(textContent)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT);

        int notificationId = createID(textTitle);
        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);

        //this if statement auto generated by android studio
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return;
        }
        notificationManager.notify(notificationId, builder.build());
    }

    public static int createID(String input) {
        int sum = 0;

        // Check for null or empty string
        if (input != null && !input.isEmpty()) {
            // Iterate through each character in the string
            for (char c : input.toCharArray()) {
                // Add the ASCII value of the character to the sum
                sum += (int) c;
            }
        }

        return sum;
    }
    public static List<String> parseForNotif(Event event){
        List<String> notif = new ArrayList<>();

        //(new Event(eventId, eventName, eventMinute, result, addition, teamName))
        if (event.getAddition().isEmpty()){
            notif.add(event.getMinute() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());

        }else{
            notif.add(event.getMinute() + " + " + event.getAddition() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());
        }
        if (event.getAddition().isEmpty()){
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + "' "  +  " the score is: " + event.getResult());


        }else{
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + " + " + event.getAddition() + "' "  +  " the score is: " + event.getResult());

        }



        return notif;
    }

    public List<LiveGame> notificationSearch() {
        List<LiveGame> liveGames = new ArrayList<>();
        int leagueID = databaseRepository.getLeague();

        try {
            //System.out.println(leagueID);
            URL url = new URL("https://api.sportmonks.com/v3/football/livescores/inplay?api_token=vHnHu2OZtUGbhPvHGl9NhDXH5iv7lSGOSPvOhJ6gYwD91Q9X3NoA2CjA1xzr&include=events;participants&filters=fixtureLeagues:" + leagueID);

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder content = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            in.close();
            connection.disconnect();

            if (content != null) {
                String jsonString = content.toString();
                //System.out.println("here " + jsonString);
                boolean shouldDelay = false;
                if (jsonString.contains("\"message\":\"No result(s) found matching your request.")) {
                    return null;
                }


                liveGames = jsonParser.parseLiveJson(jsonString);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return liveGames;
    }
}

ChatGPT
It looks like your log output is indicating that the notifCheck method is executing very quickly, with an execution time of 0 milliseconds. Additionally, there are sleep statements in your code (for 1 minute) that might be affecting the overall behavior.

Here are a few observations and suggestions:

Execution Time Calculation:
The execution time is calculated before and after the notifCheck method is called. However, since the notifCheck method itself runs in a separate thread, the calculation of the execution time doesn't accurately represent the time taken by the entire operation. The start and end times should be measured within the same thread for accurate measurement.

Thread.sleep Duration:
You have sleep statements in your code, such as Thread.sleep(10000) and Thread.sleep(60000). These sleep statements can introduce delays in the overall execution and might affect the accuracy of the scheduled execution.

Background Thread Use:
You are already using a background thread for the notifCheck method. Ensure that the background thread is not being blocked unnecessarily, and it is allowed to complete its tasks before the scheduled execution interval.

Here's a modified version of your code to address some of these concerns:

java
Copy code
private void notifCheck() {
    try {
        // Perform network-related operation in a background thread
        List<LiveGame> liveGames = this.notificationSearch();
        if (liveGames == null) {
            System.out.println("Sleep for 1 min");
            Thread.sleep(60000);
        } else {
            System.out.println(liveGames.toString());
            List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
            Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);

            // ... rest of your code ...

            System.out.println("Executing myFunction every 10 seconds");
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

@Override
public void run() {
    while (true) {
        long startTime = System.currentTimeMillis();
        notifCheck();
        long endTime = System.currentTimeMillis();
        System.out.println("Execution time: " + (endTime - startTime) + " ms");

        try {
            // Sleep for 10 seconds before the next execution
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
This modification ensures that the notifCheck method runs within the background thread, and the execution time is measured within the same thread. Additionally, the loop with a 10-second sleep ensures that the notifCheck method is called every 10 seconds. Adjust the sleep duration and other aspects based on your specific requirements and observations.

is it possible to move the sleep into the run method?
ChatGPT
Yes, you can move the sleep duration into the run method to control the overall execution interval directly within the Runnable. Here's an updated version of your code:

java
Copy code
class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;

    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final long executionInterval = 10000; // 10 seconds

    @Override
    public void run() {
        while (true) {
            long startTime = System.currentTimeMillis();
            notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");

            try {
                // Sleep for the specified interval before the next execution
                Thread.sleep(executionInterval);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // rest of your code...
}
In this version, the run method contains a while loop that runs indefinitely. After each execution of the notifCheck method, the thread sleeps for the specified interval (executionInterval). This approach keeps the control of the execution interval within the run method, making it easier to adjust as needed.

Please note that using an infinite loop (while (true)) in a background thread might be suitable for certain scenarios. However, in Android development, it's essential to manage the lifecycle of background threads properly to avoid memory leaks. Consider stopping the thread when your application is paused or destroyed to prevent issues.

I meant the conditional minute long sleep
ChatGPT
Certainly! If you want to move the conditional sleep into the run method, you can modify it as follows:

java
Copy code
class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;

    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final long executionInterval = 10000; // 10 seconds
    private final long conditionalSleepDuration = 60000; // 1 minute

    @Override
    public void run() {
        while (true) {
            long startTime = System.currentTimeMillis();
            notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");

            if (shouldSleep()) {
                try {
                    // Sleep for 1 minute if the condition is met
                    System.out.println("Sleep for 1 min");
                    Thread.sleep(conditionalSleepDuration);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    // Sleep for the specified interval before the next execution
                    Thread.sleep(executionInterval);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private boolean shouldSleep() {
        // Add your condition to determine if the conditional sleep is needed
        // For example, return true if a specific condition is met, otherwise false
        // Replace the following condition with your actual logic
        return false;
    }

    // rest of your code...
}
In this version, I added a shouldSleep method that returns a boolean based on your specific condition. If the condition is met, it sleeps for 1 minute; otherwise, it sleeps for the specified interval. Adjust the shouldSleep method according to the logic you need for the conditional sleep.

how can I change shouldSleep from notifCheck
ChatGPT
To move the shouldSleep logic into the notifCheck method, you can make a few adjustments. Here's an updated version of the code:

java
Copy code
class Notifications implements Runnable {

    // ... (other members and methods)

    @Override
    public void run() {
        while (true) {
            long startTime = System.currentTimeMillis();
            boolean shouldSleep = notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");

            if (shouldSleep) {
                try {
                    // Sleep for 1 minute if the condition is met
                    System.out.println("Sleep for 1 min");
                    Thread.sleep(conditionalSleepDuration);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    // Sleep for the specified interval before the next execution
                    Thread.sleep(executionInterval);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private boolean notifCheck() {
        long startTime = System.currentTimeMillis();
        // Your code to be executed every 10 seconds
        try {
            // Perform network-related operation in a background thread
            Thread.sleep(10000);
            List<LiveGame> liveGames = this.notificationSearch();
            if (liveGames == null) {
                System.out.println("Sleep for 1 min");
                Thread.sleep(60000);
                return true; // Return true if you want to sleep for 1 minute
            } else {
                System.out.println(liveGames.toString());
                List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
                Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);

                // ... rest of your code ...

                System.out.println("Executing myFunction every 10 seconds");
                return false; // Return false if you don't want to sleep for 1 minute
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            return false;
        } finally {
            long endTime = System.currentTimeMillis();
            System.out.println("notifCheck execution time: " + (endTime - startTime) + " ms");
        }
    }

    // ... (other members and methods)
}
In this version, the notifCheck method returns a boolean (true or false) based on your condition. If the condition is met, the run method will sleep for 1 minute; otherwise, it will sleep for the specified interval. Adjust the notifCheck method and the condition inside it according to your specific requirements.

what about conditionalSleepDuration
ChatGPT
If you want to determine the conditionalSleepDuration dynamically within the notifCheck method, you can modify it to return the appropriate sleep duration based on your conditions. Here's an example:

java
Copy code
class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final long executionInterval = 10000; // 10 seconds

    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    @Override
    public void run() {
        while (true) {
            long startTime = System.currentTimeMillis();
            long conditionalSleepDuration = notifCheck();
            long endTime = System.currentTimeMillis();
            System.out.println("Execution time: " + (endTime - startTime) + " ms");

            try {
                // Sleep for the determined duration
                System.out.println("Sleep for " + conditionalSleepDuration + " ms");
                Thread.sleep(conditionalSleepDuration);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private long notifCheck() {
        long startTime = System.currentTimeMillis();
        // Your code to be executed every 10 seconds
        try {
            // Perform network-related operation in a background thread
            Thread.sleep(10000);
            List<LiveGame> liveGames = this.notificationSearch();
            if (liveGames == null) {
                System.out.println("Sleep for 1 min");
                Thread.sleep(60000);
                return 60000; // Return the sleep duration in milliseconds
            } else {
                System.out.println(liveGames.toString());
                List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
                Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);

                // ... rest of your code ...

                System.out.println("Executing myFunction every 10 seconds");
                return executionInterval; // Return the default sleep duration
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            return executionInterval; // Return the default sleep duration in case of an exception
        } finally {
            long endTime = System.currentTimeMillis();
            System.out.println("notifCheck execution time: " + (endTime - startTime) + " ms");
        }
    }

    // ... (other members and methods)
}
In this example, notifCheck now returns the sleep duration in milliseconds. If the condition is met, it returns the specified conditionalSleepDuration; otherwise, it returns the default executionInterval. Adjust the logic inside notifCheck as needed for your application's requirements.







how would I edit this code:
public void sendNotif(Event event, int id) {
        final String CHANNEL_ID = "App_Title_id";
        List<String> notif = new ArrayList<>();
        notif = parseForNotif(event);
        String textTitle = notif.get(0);
        String textContent = notif.get(1);
        Context context = this.context;
        Intent intent = new Intent(context, liveGameDetails.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_IMMUTABLE);

        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)
                .setContentTitle(textTitle)
                .setContentText(textContent)
                .setContentIntent(pendingIntent)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT);

        int notificationId = createID(textTitle);
        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);

        //this if statement auto generated by android studio
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return;
        }
        notificationManager.notify(notificationId, builder.build());
    }


so that the id parameter gets passed into liveGameDetails so that it can be unpacked with the line:
itemId = bundle.getInt("ITEM_ID", -1);
ChatGPT
To pass the id parameter to the liveGameDetails activity and retrieve it using the getIntent() method, you can modify the sendNotif method as follows:

java
Copy code
public void sendNotif(Event event, int id) {
    final String CHANNEL_ID = "App_Title_id";
    List<String> notif = parseForNotif(event);
    String textTitle = notif.get(0);
    String textContent = notif.get(1);
    Context context = this.context;

    // Pass the 'id' parameter to the liveGameDetails activity
    Intent intent = new Intent(context, liveGameDetails.class);
    intent.putExtra("ITEM_ID", id);  // Add this line to pass the 'id' parameter
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_IMMUTABLE);

    NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle(textTitle)
            .setContentText(textContent)
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT);

    int notificationId = createID(textTitle);
    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);

    // Check for the permission
    if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
        // TODO: Handle the case where the permission is not granted
        return;
    }

    notificationManager.notify(notificationId, builder.build());
}
Now, in the liveGameDetails activity, you can retrieve the id parameter as follows:

java
Copy code
public class liveGameDetails extends AppCompatActivity {

    private int itemId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_live_game_details);

        // Retrieve the 'id' parameter from the intent
        Bundle bundle = getIntent().getExtras();
        if (bundle != null) {
            itemId = bundle.getInt("ITEM_ID", -1);
        }

        // Rest of your code...
    }
}
Now, the id parameter will be passed from the notification to the liveGameDetails activity, and you can unpack it using the getIntent().getExtras() method.






create me a java function that takes a string and returns the sum of the ascii value of each character  as an int
ChatGPT
Certainly! Here's a simple Java function that takes a string and returns the sum of the ASCII values of each character:

java
Copy code
public class AsciiSumCalculator {

    public static int calculateAsciiSum(String input) {
        int sum = 0;

        // Check for null or empty string
        if (input != null && !input.isEmpty()) {
            // Iterate through each character in the string
            for (char c : input.toCharArray()) {
                // Add the ASCII value of the character to the sum
                sum += (int) c;
            }
        }

        return sum;
    }

    public static void main(String[] args) {
        // Example usage
        String inputString = "Hello, World!";
        int asciiSum = calculateAsciiSum(inputString);
        System.out.println("ASCII Sum: " + asciiSum);
    }
}
In this example, the calculateAsciiSum function takes a string (input) as a parameter and returns the sum of the ASCII values of its characters. The function iterates through each character in the string using a for-each loop and adds the ASCII value of each character to the sum variable. Finally, the function returns the total sum.

The main method demonstrates an example usage of the function with the string "Hello, World!". You can replace this string with any other string for testing.



explain why notifications might not be showing up for my java android studio app
ChatGPT
There could be several reasons why notifications might not be showing up for your Java Android Studio app. Here are some common issues and solutions you can consider:

Permissions:

Ensure that your app has the necessary permissions to show notifications. In the AndroidManifest.xml file, make sure you have the <uses-permission android:name="android.permission.INTERNET" /> permission if your notifications involve network operations.
Notification Channel:

Starting from Android 8.0 (API level 26), you need to use notification channels. Make sure you are creating and assigning notifications to the correct notification channel.
Example of creating a notification channel:
java
Copy code
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    NotificationChannel channel = new NotificationChannel("channel_id", "Channel Name", NotificationManager.IMPORTANCE_DEFAULT);
    NotificationManager manager = getSystemService(NotificationManager.class);
    manager.createNotificationChannel(channel);
}
Notification Builder:

Double-check your Notification Builder code to ensure that you are setting the required properties such as content title, content text, and small icon.
Example of creating a simple notification:
java
Copy code
NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "channel_id")
        .setSmallIcon(R.drawable.ic_notification)
        .setContentTitle("Title")
        .setContentText("Content text")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);
Doze Mode:

On Android devices running Android 6.0 (API level 23) and higher, the Doze mode may affect how notifications are delivered. Check if your app is exempted from Doze mode restrictions.
Background Restrictions:

Starting from Android 8.0, background execution limits may affect your app's ability to show notifications in the background. Ensure that your app handles background restrictions appropriately.
Testing on Emulator/Device:

Test your app on a real device rather than just the emulator, as some features related to notifications may behave differently on real devices.
Logcat:

Check the Logcat output in Android Studio for any error messages or warnings related to notifications. This can provide insights into what might be going wrong.
Other Libraries/Services:

If you are using any third-party libraries or services for notifications, make sure they are correctly configured and integrated.
App State:

Notifications might not show up if your app is in a state where it's not actively running. Ensure that your app's logic for triggering notifications is working as expected.
Update Libraries:

Ensure that you are using the latest versions of the Android Support Library and other relevant dependencies.
By carefully checking these points, you should be able to identify and resolve the issue preventing notifications from showing up in your Java Android Studio app.

User
here is the code that manages the notifications
 package com.example.mobileappdevcoursework;


import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.util.Log;

import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;

import com.example.mobileappdevcoursework.data.DatabaseRepository;
import com.example.mobileappdevcoursework.data.FollowedGame;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

class Notifications implements Runnable {

    private Context context;
    private DatabaseRepository databaseRepository;
    private static final String TAG = "Notifications";


    public Notifications(Context context, DatabaseRepository databaseRepository) {
        this.context = context;
        this.databaseRepository = databaseRepository;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);


    @Override // https://chat.openai.com/share/44cc401f-7c49-4484-830b-f51375a05d0a
    public void run() {
        while (true) {
            long startTime = System.currentTimeMillis();
            List<FollowedGame> followedGames = databaseRepository.getAllFollowed();
            Map<Integer, Integer> followedGamesMap = convertListToMap(followedGames);
            List<LiveGame> liveGames = this.notificationSearch();
            boolean shouldSleep = false;
            if(followedGamesMap == null){
                shouldSleep = true;
            } else{
                //logic to send notifications
                //for game in followed game
//                int oldCount = databaseRepository.getEventCount() // followed game id

                for (LiveGame game : liveGames) {
                    if (followedGamesMap.get(game.getId()) != null) {
                        int newCount = game.getEvents().size();
                        int oldCount = followedGamesMap.get(game.getId());
                        System.out.println(followedGamesMap.get(game.getId()));
                        Log.d(TAG, String.valueOf(newCount));
                        Log.d(TAG, String.valueOf(oldCount));

                        if (newCount > oldCount) {
                            for (int i = oldCount; i < newCount; i++) {
                                if (i < game.getEvents().size()) {
                                    Event event = game.getEventAtIndex(i);
                                    sendNotif(event, game.getId(), game.leagueId);
                                    // System.out.println("Event at index " + i + ": " + event);
                                }
                            }
                        }
                    }
                }

                for (Map.Entry<Integer, Integer> entry : followedGamesMap.entrySet()){ //https://chat.openai.com/share/99c6ed7e-ed94-4ab5-a15a-3c708848e7bb
                    Integer gameId = entry.getKey();

                    // Check if the game with gameId is in liveGames
                    boolean isGameInLiveGames = liveGames.stream().anyMatch(game -> game.getId() == gameId);

                    if (!isGameInLiveGames) {
                        // Call your method here for games that are in followedGames but not in liveGames
                        databaseRepository.deleteFollowedGame(gameId);
                    }
                }
            }


            if (shouldSleep) {
                try {
                    // Sleep for 1 minute if the condition is met
                    System.out.println("Sleep for 1 min");
                    Thread.sleep(60000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    // Sleep for the specified interval before the next execution
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }



    private static Map<Integer, Integer> convertListToMap(List<FollowedGame> followedGamesList) {
        Map<Integer, Integer> gameIdToEventCountMap = new HashMap<>();
        for (FollowedGame game : followedGamesList) {
            gameIdToEventCountMap.put(game.getGameID(), game.getEventCount());
        }
        return gameIdToEventCountMap;
    }

    public void sendNotif(Event event, int id, int leagueId) {
        // https://developer.android.com/develop/ui/views/notifications/build-notification#java
        // https://chat.openai.com/share/b2695ba0-3441-4722-9de4-665c551640c7
        final String CHANNEL_ID = "App_Title_id";
        List<String> notif = new ArrayList<>();
        notif = parseForNotif(event);
        String textTitle = notif.get(0);
        String textContent = notif.get(1);
        Context context = this.context;
        Intent intent = new Intent(context, LiveGameDetails.class);
        intent.putExtra("ITEM_ID", id);
        intent.putExtra("LEAGUE_ID", leagueId);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_IMMUTABLE);

        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)
                .setContentTitle(textTitle)
                .setContentText(textContent)
                .setContentIntent(pendingIntent)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT);

        int notificationId = createID(textTitle);
        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);

        //this if statement auto generated by android studio
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the User grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return;
        }
        notificationManager.notify(notificationId, builder.build());
        Log.d(TAG, "Notification sent");
    }

    public static int createID(String input) {
        int sum = 0;

        // Check for null or empty string
        if (input != null && !input.isEmpty()) {
            // Iterate through each character in the string
            for (char c : input.toCharArray()) {
                // Add the ASCII value of the character to the sum
                sum += (int) c;
            }
        }

        return sum;
    }
    public static List<String> parseForNotif(Event event){
        List<String> notif = new ArrayList<>();

        //(new Event(eventId, eventName, eventMinute, result, addition, teamName))
        if (event.getAddition().isEmpty()){
            notif.add(event.getMinute() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());

        }else{
            notif.add(event.getMinute() + " + " + event.getAddition() + "' "  + event.getName() + " " + event.getTeam() + " " + event.getResult());
        }
        if (event.getAddition().isEmpty()){
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + "' "  +  " the score is: " + event.getResult());


        }else{
            notif.add(event.getName() + " for  " + event.getTeam() + " at minute " + event.getMinute() + " + " + event.getAddition() + "' "  +  " the score is: " + event.getResult());

        }



        return notif;
    }

    public List<LiveGame> notificationSearch() {
        List<LiveGame> liveGames = new ArrayList<>();
        int leagueID = databaseRepository.getLeague();

        try {
            //System.out.println(leagueID);
            URL url = new URL("https://api.sportmonks.com/v3/football/livescores/inplay?api_token=vHnHu2OZtUGbhPvHGl9NhDXH5iv7lSGOSPvOhJ6gYwD91Q9X3NoA2CjA1xzr&include=events;participants&filters=fixtureLeagues:" + leagueID);

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder content = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            in.close();
            connection.disconnect();

            if (content != null) {
                String jsonString = content.toString();
                //System.out.println("here " + jsonString);
                boolean shouldDelay = false;
                if (jsonString.contains("\"message\":\"No result(s) found matching your request.")) {
                    return null;
                }


                liveGames = JsonParse.parseLiveJson(jsonString, leagueID);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return liveGames;
    }
}
ChatGPT
Your code for handling notifications seems comprehensive, and I don't see any major issues with it. However, I have a few suggestions and improvements that might help:

Notification Channel:

Ensure that you create a notification channel before posting notifications. It's essential for Android versions 8.0 (Oreo) and above. You can create it in your application's initialization code or in the onCreate method of your main activity.
java
Copy code
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    NotificationChannel channel = new NotificationChannel("App_Title_id", "Your Channel Name", NotificationManager.IMPORTANCE_DEFAULT);
    NotificationManager manager = context.getSystemService(NotificationManager.class);
    manager.createNotificationChannel(channel);
}
Check Permissions:

You have a check for POST_NOTIFICATIONS permission, but this permission does not exist. Ensure that you have the necessary permissions in your manifest file.
Handle Network Operations on a Separate Thread:

Network operations, such as fetching data from a URL, should be performed on a separate thread to avoid blocking the main thread. You might consider using an AsyncTask or other background processing mechanisms.
Avoid Infinite Loop:

Be cautious about the infinite loop in your run method. It might be a good idea to add a condition to exit the loop gracefully when needed, for example, when the application is paused or stopped.
Use WorkManager or JobIntentService:

Instead of using a custom thread for periodic tasks, consider using Android's WorkManager or JobIntentService for background tasks. These are more suitable for periodic and background tasks, and they handle the job scheduling efficiently.
Ensure Unique Notification IDs:

When generating notification IDs using the createID method, make sure the generated IDs are unique. You could use a more robust method, such as using a combination of event ID and timestamp.
Log Notification Creation Failure:

Add logging or error handling in case there's an issue creating or posting notifications. Check the logcat for any error messages related to notifications.
Test on Multiple Devices:

Test your notification code on multiple devices and Android versions to ensure compatibility.
Handle Exception More Gracefully:

Improve exception handling in your notificationSearch method. Consider logging or handling exceptions more gracefully to prevent crashes.
Use Constants for API URL and Token:

Consider using constants for the API URL and token to make your code more maintainable and easily configurable.
Remember to adapt these suggestions based on your specific requirements and the architecture of your application. Additionally, check the Android documentation for any updates or changes related to notifications and background processing.


2 / 2

User
here is my main activity

package com.example.mobileappdevcoursework;

import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.navigation.NavController;
import androidx.navigation.fragment.NavHostFragment;

import com.example.mobileappdevcoursework.data.DatabaseRepository;
import com.example.mobileappdevcoursework.databinding.ActivityMainBinding;

import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    ActivityMainBinding binding;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //setContentView(R.layout.activity_main);


        //code for the navigation bar comes from https://www.youtube.com/watch?v=jOFLmKMOcK0 , accessed 14/11/2023 at 10am the switch case at 7:54 was adapted to a series of if else statements to fix a constant expression required error
        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());


        NavHostFragment navHostFragment = (NavHostFragment) getSupportFragmentManager().findFragmentById(R.id.nav_host_fragment);

        //replaceFragment(new HomeFragment());
        NavController navController = navHostFragment.getNavController();


        new Thread(() -> {
            createNotificationChannel();
            LiveViewModel viewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(LiveViewModel.class);
            DatabaseRepository databaseRepository = DatabaseRepository.getRepository(this);
            Notifications notificationManager = new Notifications(this,  databaseRepository);
            notificationManager.run();
        }).start();


        binding.bottomNavigationView.setOnNavigationItemSelectedListener(item -> {
            if (item.getItemId() == R.id.main) {
                navController.navigate(R.id.HomeFragment);
                return true;
            } else if (item.getItemId() == R.id.profile) {
                navController.navigate(R.id.userProfile);
                return true;
            } else if (item.getItemId() == R.id.live) {
                navController.navigate(R.id.liveScores);
                return true;
            }
            return false;
        });


    }

    private void createNotificationChannel() {
        // Create the NotificationChannel, but only on API 26+ because
        // the NotificationChannel class is not in the Support Library.
        final String CHANNEL_ID = "App_Title_id";

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            CharSequence name = getString(R.string.channel_name);
            String description = getString(R.string.channel_description);
            int importance = NotificationManager.IMPORTANCE_DEFAULT;
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
            channel.setDescription(description);
            // Register the channel with the system; you can't change the importance
            // or other notification behaviors after this.
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(channel);
        }
    }

    private void replaceFragment(Fragment fragment) {
        Log.d("MainActivity", "Replacing fragment with " + fragment.getClass().getSimpleName());

        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        if (fragment != null) {
            fragmentTransaction.replace(R.id.frameLayout, fragment);
            fragmentTransaction.commit();
        } else {
            Log.e("MainActivity", "Fragment is null");
        }

    }

how do I check for permissions

2 / 2

ChatGPT
To check for permissions in Android, you typically use the ContextCompat.checkSelfPermission() method. Here's an example of how you can check for a specific permission in your MainActivity:

java
Copy code
import android.Manifest;
import android.content.pm.PackageManager;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

// Inside your MainActivity class...

private static final int MY_PERMISSION_REQUEST_CODE = 123; // You can use any value here

// ...

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // ...

    // Check for permissions
    if (checkPermissions()) {
        // Permissions are already granted
        // Proceed with your application logic
    } else {
        // Request permissions
        requestPermissions();
    }

    // ...
}

private boolean checkPermissions() {
    // Check if the required permission is granted
    return ContextCompat.checkSelfPermission(this, Manifest.permission.YOUR_PERMISSION) == PackageManager.PERMISSION_GRANTED;
}

private void requestPermissions() {
    // Request the permission
    ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.YOUR_PERMISSION}, MY_PERMISSION_REQUEST_CODE);
}

// ...

// Override onRequestPermissionsResult to handle the result of the permission request
@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    if (requestCode == MY_PERMISSION_REQUEST_CODE) {
        // Check if the permission was granted
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            // Permission granted, proceed with your application logic
        } else {
            // Permission denied, handle this situation (e.g., show a message, disable functionality)
        }
    }
}
Replace Manifest.permission.YOUR_PERMISSION with the actual permission you want to check.

In this example, checkPermissions() checks if the permission is already granted, and if not, it calls requestPermissions() to request the permission. The result of the permission request is handled in the onRequestPermissionsResult method.

Note: Make sure to declare the necessary permissions in your AndroidManifest.xml file.




explain how I would call an api in java, the api is https://api.sportmonks.com/ use [key] where the api key should go
ChatGPT
To call an API in Java, you'll need to use the HttpURLConnection class (or a higher-level library like HttpClient if you prefer). Here's a basic example of how you can make a GET request to the Sportmonks API using Java:

java
Copy code
import java.net.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        try {
            String apiKey = "[key]"; // Replace [key] with your actual API key

            URL url = new URL("https://api.sportmonks.com/v2/endpoint"); // Replace endpoint with the specific endpoint you want to access
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Api-Token", apiKey);

            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder content = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }

            in.close();
            connection.disconnect();

            System.out.println(content.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
Here's what's happening in this code:

Replace [key] with your actual API key.
Create a URL object with the endpoint you want to access.
Open a HttpURLConnection.
Set the request method to "GET" (since you're making a GET request).
Set the Api-Token header with your API key.
Create a BufferedReader to read the response.
Read the response line by line and append it to a StringBuilder.
Close the input stream and disconnect the connection.
Print the response.
Make sure to handle exceptions appropriately in a real application. This example is very basic and does not include error handling.

Keep in mind that you'll need to replace "https://api.sportmonks.com/v2/endpoint" with the actual endpoint you want to access. Make sure you're using the correct endpoint for the specific data you want to retrieve from the Sportmonks API.









why do I get
C:\Users\Jake\AndroidStudioProjects\MobileAppDevCoursework\app\src\main\java\com\example\mobileappdevcoursework\data\FollowedGameDatabase.java:11: warning: Schema export directory is not provided to the annotation processor so we cannot export the schema. You can either provide `room.schemaLocation` annotation processor argument OR set exportSchema to false.
public abstract class FollowedGameDatabase extends RoomDatabase {
                ^
C:\Users\Jake\AndroidStudioProjects\MobileAppDevCoursework\app\src\main\java\com\example\mobileappdevcoursework\data\GameDatabase.java:7: warning: Schema export directory is not provided to the annotation processor so we cannot export the schema. You can either provide `room.schemaLocation` annotation processor argument OR set exportSchema to false.
public abstract class GameDatabase extends RoomDatabase{
                ^
C:\Users\Jake\AndroidStudioProjects\MobileAppDevCoursework\app\src\main\java\com\example\mobileappdevcoursework\data\UserDatabase.java:7: warning: Schema export directory is not provided to the annotation processor so we cannot export the schema. You can either provide `room.schemaLocation` annotation processor argument OR set exportSchema to false.
public abstract class UserDatabase extends RoomDatabase{
                ^
Note: C:\Users\Jake\AndroidStudioProjects\MobileAppDevCoursework\app\src\main\java\com\example\mobileappdevcoursework\MainActivity.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.

when I run JUnit4 tests on
package com.example.mobileappdevcoursework;

import android.os.Bundle;

import androidx.fragment.app.Fragment;

import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;

import com.example.mobileappdevcoursework.data.DatabaseRepository;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

/**
 * A simple {@link Fragment} subclass.
 * Use the {@link GameDetails#newInstance} factory method to
 * create an instance of this fragment.
 */
//shows more in depth information about a chosen game, accessed from HomeFragment
public class GameDetails extends Fragment{

    private DatabaseRepository databaseRepository; //instance of roomDB database
    private static final String TAG = "GameDetails";

    public GameDetails() {
        // Required empty public constructor
    }

    public static GameDetails newInstance() {
        GameDetails fragment = new GameDetails();
        Bundle args = new Bundle();
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, " onCreate");
        databaseRepository = databaseRepository.getRepository(getContext());

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        Bundle bundle = getArguments();
        View view = inflater.inflate(R.layout.fragment_game_details, container, false);

        //initialising textviews and calendar button
        TextView titleTextView = view.findViewById(R.id.titleTextView);
        TextView timeView = view.findViewById(R.id.timeView);
        TextView venueView = view.findViewById(R.id.venueView);
        TextView homeView = view.findViewById(R.id.homeView);
        TextView awayView = view.findViewById(R.id.awayView);
        TextView homePosView = view.findViewById(R.id.homePosView);
        TextView awayPosView = view.findViewById(R.id.awayPosView);
        Button calendarBtn = view.findViewById(R.id.calendarBtn);



        if (bundle != null) {
        new Thread(new Runnable() { //getting data from API and filling textViews
            @Override
            public void run() {

                    // Extract the item_id from the Bundle
                    int itemId = bundle.getInt("ITEM_ID", -1); //get the id of the game chosen from HomeFragment
                    int leagueID = databaseRepository.getLeague();  //get the users chosen league
                    String baseURL = "https://api.sportmonks.com/v3/football/fixtures/" + itemId + "?api_token=vHnHu2OZtUGbhPvHGl9NhDXH5iv7lSGOSPvOhJ6gYwD91Q9X3NoA2CjA1xzr&include=events;participants&filters=fixtureLeagues:" + leagueID;
                    try{


                        URL url = new URL(baseURL);

                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();


                        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                        String inputLine;
                        StringBuilder content = new StringBuilder();

                        while ((inputLine = in.readLine()) != null) {
                            content.append(inputLine);
                        }
                        in.close();
                        connection.disconnect();

                        String jsonString = content.toString();
                        GameInstance thisGame = JsonParse.parseGame(jsonString); //creates a GameInstance object using the json


                        // Update the UI on the ui thread
                        requireActivity().runOnUiThread(new Runnable() {
                            @Override
                            public void run() {


                                venueView.setText("Venue: " + thisGame.getVenueName());


                            }
                        });


                        getActivity().runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                titleTextView.setText(thisGame.getGameName());
                                timeView.setText(thisGame.getStartTime());
                                homeView.setText(thisGame.getHomeName());
                                awayView.setText(thisGame.getAwayName());
                                homePosView.setText(String.valueOf(thisGame.getHomeTeamPosition()));
                                awayPosView.setText(String.valueOf(thisGame.getAwayTeamPosition()));

                                // Set the click listener for calendarBtn here
                                calendarBtn.setOnClickListener(new OnCalendarClickListener(thisGame));



                            }
                        });





                    } catch (Exception e) {
                        e.printStackTrace();
                    }


                }
            }).start();

        };
        return view;
    }
}

ChatGPT
The warning you are seeing is related to Room, which is an Android Architecture Component used for working with databases. The warning suggests that you haven't specified a location for exporting the Room database schema.

To fix this issue, you need to provide a location for exporting the schema. You can do this by adding the room.schemaLocation annotation processor argument to your Gradle build file. Here's an example of how you can do it:

Open your app-level build.gradle file.

Inside the android block, add the following:

gradle
Copy code
android {
    // ...

    defaultConfig {
        // ...

        javaCompileOptions {
            annotationProcessorOptions {
                arguments = ["room.schemaLocation": "$projectDir/schemas".toString()]
            }
        }
    }

    // ...
}
This configuration tells the Room annotation processor to export the schema to the "schemas" directory in your project.

After making this change, sync your project with Gradle.

Once you've done this, the warning should disappear. Make sure to replace "schemas" with the desired directory path where you want to store the Room database schema files.

If you don't want to export the schema at all, you can set the exportSchema option to false in your Room database class:

java
Copy code
@Database(entities = {YourEntity.class}, version = 1, exportSchema = false)
public abstract class YourDatabase extends RoomDatabase {
    // ...
}
Adding this line to your database class will also suppress the warning.
